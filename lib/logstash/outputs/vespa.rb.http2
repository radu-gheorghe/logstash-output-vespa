# encoding: utf-8
require "logstash/outputs/base"
require "logstash/namespace"
require "httpx"
require "json"
require "uri"
require "securerandom"

class LogStash::Outputs::Vespa < LogStash::Outputs::Base
  config_name "vespa"

  # URL to the Vespa instance
  config :vespa_url, :validate => :string, :required => true, :default => "http://localhost:8080"

  # Content cluster name. You should see it in the Vespa services.xml file as "id" in the <content> tag
  config :content_cluster, :validate => :string, :required => true

  # Document type name. You should see it in the Vespa services.xml file as well as in the schema file
  config :document_type, :validate => :string, :required => true

  # field name to use as the document id. If not present, a UUID will be generated
  config :id_field, :validate => :string, :default => "id"

  # On failure, retry this many times
  config :max_retries, :validate => :number, :default => 60

  concurrency :shared

  public
  def register
    # initialize a dead letter queue writer
    @dlq_writer = execution_context.dlq_writer

    @base_uri = URI.parse(@vespa_url)
  end # def register

  public
  def multi_receive(events)
    return if events.empty?

    # HTTPX client with HTTP/2 support and retries
    http_client = HTTPX.with(:http2).plugin(:retries, max_retries: @max_retries).with(
      persistent: true,
      max_concurrent_requests: 100,
      buffer_size: 64_000,   # 64 KB r/w buffer
      window_size: 64_000    # 64 KB flow control window
    )

    # initialize list of requests
    requests = []

    events.map do |event|
      # If there's a document "id" field, we should use it as the document id
      # Otherwise, we generate a UUID
      id = event.get(@id_field) || SecureRandom.uuid
  
      # Build the path from the cluster name, document type, and document id
      uri = @base_uri.dup
      uri.path = "/document/v1/#{@content_cluster}/#{@document_type}/docid/#{id}"
  
      document = {
        "fields" => event.to_hash
      }

      # Build the request. We don't run it yet
      request = http_client.build_request(:post, uri.to_s, json: document)
      # add it to the list of requests
      requests << request
    end # events.map

    @logger.debug("Sending #{requests.size} requests to Vespa")
    # Run all requests async
    responses = http_client.request(*requests)

    # Handle responses
    responses.each do |response|
      if response.status != 200
        # Handle non-200 response by writing to the DLQ
        # TODO Should we retry some of those?
        @logger.error("Error sending event to Vespa. Writing to dead letter queue (if configured).",
                      :response_code => response.status, :response_body => response.body)
        # TODO fix this, we need to write the corresponding event
        @dlq_writer.write(event, response.body)
      end
    end
  
  rescue => e
    @logger.error("Exception caught while sending events to Vespa. Writing to dead letter queue (if configured).", :exception => e)
    events.each do |event|
      @dlq_writer.write(event, e.message)
    end
  end # def multi_receive
end # class LogStash::Outputs::Vespa